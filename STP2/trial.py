from Crypto.Util.number import long_to_bytes, inverse

# Given parameters
n = 58211724680090395977515388010075618267512306421409412111828360531917470152160057693760674616211615577020755504246901081708717917271451174900976602584768945649858700514741548295339288913787829833483086772418864856336350346660091773105701084458949677136000695666021547643365582866834333015864134844962846449007
e = 65537
c = 25626568137656112192737259995953968731328551585187211696261866572334093047163697218384486921241922467496241949733922542553587263601659350532360230076208848066320649205686501892194546439460512596530133404102186018259888850822880522773913833936611838175158995149305743754485551962802841358551190025058474836853

# Function to decrypt assuming k is a small integer
def decrypt(c, k, n, e):
    k_inv = pow(k, -e, n)
    m = (c * k_inv) % n
    return m

# Try small values of k
for k in range(1, 100):  # You can increase this range
    m = decrypt(c, k, n, e)
    # Convert m to bytes and try to decode it
    try:
        flag = long_to_bytes(m).decode('utf-8')
        print(f"Possible flag with k={k}: {flag}")
    except Exception as ex:
        continue # Ignore decoding errors
